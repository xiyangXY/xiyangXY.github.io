[{"title":"微前端解决方案 qiankun","url":"/2021/11/19/qiankun/","content":"[qiankun](https://qiankun.umijs.org/zh) 是蚂蚁团队出品的微前端解决方案，它基于 [single-spa](https://github.com/single-spa/single-spa) 封装，使用层面不局限于前端框架的种类，能在任意技术栈的应用使用和介入，接入像使用 iframe 一样，简单方便快捷高效。\n\n<!-- more -->\n微前端\n=================\n\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n微前端架构具备以下几个核心价值：\n* 技术栈无关\n主框架不限制接入应用的技术栈，微应用具备完全自主权\n\n* 独立开发、独立部署\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n\n* 增量升级\n在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n\n* 独立运行时\n每个微应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\nqiankun\n=================\n\n介绍\n-----------------\n[qiankun](https://qiankun.umijs.org/zh) 是蚂蚁团队出品的微前端解决方案，它基于 [single-spa](https://github.com/single-spa/single-spa) 封装，使用层面不局限于前端框架的种类，能在任意技术栈的应用使用和介入，接入像使用 iframe 一样，简单方便快捷高效。\n\n核心设计理念\n-----------------\n* 🥄 简单\n由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。\n\n* 🍡 解耦/技术栈无关\n微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。\n\n特性\n-----------------\n* 📦 基于 [single-spa](https://github.com/single-spa/single-spa) 封装，提供了更加开箱即用的 API。\n* 📱 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。\n* 💪 HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。\n* 🛡​ 样式隔离，确保微应用之间样式互相不干扰。\n* 🧳 JS 沙箱，确保微应用之间 全局变量/事件 不冲突。\n* ⚡️ 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。\n* 🔌 umi 插件，提供了 [@umijs/plugin-qiankun](https://github.com/umijs/plugins/tree/master/packages/plugin-qiankun) 供 umi 应用一键切换成微前端架构系统。\n\n快速上手\n-----------------\n### 安装qiankun\n```\nnpm i qiankun -S\n```\n\n### 主应用\n主应用搭建参考qiankun官网\n[主应用](https://qiankun.umijs.org/zh/guide/getting-started#%E4%B8%BB%E5%BA%94%E7%94%A8)\n\n### 微应用\n微应用搭建参考qiankun官网\n[微应用](https://qiankun.umijs.org/zh/guide/getting-started#%E5%BE%AE%E5%BA%94%E7%94%A8)\n\n### 基于vue-cli项目实践\n1. 主应用\n* 入口文件 main.js\n```\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\n// 导入qiankun.js\nimport {registerMicroApps,setDefaultMountApp,start} from \"qiankun\";\nVue.config.productionTip = false\n\nnew Vue({\n  router,\n  render: h => h(App),\n}).$mount('#app')\n\n// 注册子应用\nregisterMicroApps([\n  {\n    name: 'home',\t\t\t// 子应用名称\n    entry: '//localhost:8081',\t// 子应用入口\n    container: '#container',\t// 子应用所在容器\n    activeRule: '/',\t\t\t// 子应用触发规则（路径）\n  },\n]);\n\n// 启动默认应用\nsetDefaultMountApp('/')\n\n// 开启服务,配置项见官方文档\nstart()\n```","tags":["qiankun"],"categories":["前端","微前端"]},{"title":"数组排序 sort","url":"/2021/11/08/sort/","content":"使用高阶函数 sort() 来实现数组排序\n\n<!-- more -->\n排序算法\n=================\n\n排序的核心是比较两个元素的大小，在比较数字的时候我们可以根据数字的大小来进行排序，但是实际在写程序的时候我们可能需要处理更为复杂场景的排序功能，比方说比较字符串或者是对象，这个时候直接比较数字的大小是没有意义的，我们需要把处理方法函数抽离出来。\n\n通常规定x， y两个元素，当x < y 的时候， 就返回 -1；当 x == y 的时候，就返回 0；如果 x > y 的时候，就返回 1。这样排序算法不需要关心具体的比较过程，而是根据排序结果直接进行排序。\n\nJavaScript的Array的sort()方法就是用于排序的, 在使用之前请先了解该方法的默认排序规则，否则你会得到意想不到的结果: \n```\n    var arr = [2, 1, 10, 5, 7]\n    arr.sort()\n\n    // 你以为的结果\n    console.log(arr); // [1, 2, 5, 7, 10]\n\n    // 真实结果\n    console.log(arr); // [1, 10, 2, 5, 7]\n```\n\n发生以上结果是因为Array的sort()方法默认会把所有元素先转成String类型进行排序，字符串根据ASCII码进行排序。\n\n数字排序\n---------------\n\n我们在使用sort()方法进行排序的时候，传入一个自定义函数来实现自定义排序。\n比方说我们要实现一个从小到大的排序方法，我们可以这么写\n```\nvar arr = [100, 20, 35, 46];\narr.sort(function (x, y) {\n    if (x < y) return -1;\n    if (x > y) return 1;\n    return 0;\n});\nconsole.log(arr); // [20, 35, 46, 100]\n```\n\n如果是从大到小，可以把代码稍作调整，如下\n```\nvar arr = [100, 20, 35, 46];\narr.sort(function (x, y) {\n    if (x < y) return 1;\n    if (x > y) return -1;\n    return 0;\n});\nconsole.log(arr); // [100, 46, 35, 20]\n```\n\n字符串排序\n---------------\n\n默认情况下，对字符串排序，是按照ASCII的大小比较的，那么我们排序应该忽略大小写，按照字母序排序。\n\n```\nvar arr = ['Google', 'apple', 'Microsoft'];\narr.sort(function (x, y) {\n    a = x.toUpperCase();\n    b = y.toUpperCase();\n    if (a < b)  return -1;\n    if (a > b) return 1;\n    return 0;\n}); \n//console.log(arr); ['apple', 'Google', 'Microsoft']\n```\n\n注意: 使用sort()方法会修改原数组\n```\nvar arr = [2, 1, 5, 7]\narr.sort()\nconsole.log(arr); // [1, 2, 5, 7]\n```\n\n<!-- ![nodejs](/images/liunx-node.png) -->\n\n\n\n","tags":["javascript"],"categories":["前端"]},{"title":"Linux服务器安装git","url":"/2021/11/06/liunx-git/","content":"Linux服务器安装git\n\n<!-- more -->\n安装git\n=================\n\n这里介绍的是使用 `yum` 来安装，去服务器执行以下命令\n``` cmd\n    yum -y install git\n```\n\n查询一下是否安装完成\n\n``` cmd\n    git --version\n```\n\n看到以下结果表明安装完成\n\n![linux-git](/images/linux-git.png)\n\n下面说一下git安装在服务器的位置 /usr/libexec/git-core\n\n![linux-git-azdz](/images/linux-git-azdz.jpg)\n\n\n\n\n\n","tags":["git","Linux"],"categories":["Linux"]},{"title":"Linux服务器安装nodejs","url":"/2021/11/06/liunx-node/","content":"Linux服务器安装nodejs\n\n<!-- more -->\n下载nodejs\n=================\n\n[nodejs官网](http://nodejs.cn/download/current/)，选择 `Linux 二进制文件 (x64)` 进行下载\n\n![nodejs](/images/liunx-node.png)\n\n上传包并解压\n=================\n\n我这里使用 `Xftp` 工具将包上传至服务器的/usr/local/src目录下\n\n![nodejs](/images/liunx-node-upload.png)\n\n登录 `Xshell`，访问/usr/local/src目录，执行解压命令\n\n``` cmd\ncd /usr/local/src\ntar -xvf node-v14.18.1-linux-x64.tar.xz\n```\n\n解压完成\n![nodejs](/images/node-jy.png)\n\n检查解压后的文件夹资源是否完整，若不完整重新解压，如果还不行那就重新下载包重复以上操作\n![nodejs](/images/node-sfwz.png)\n\n全局引用\n=================\n创建软连接\n\n``` cmd\nln -s /usr/local/src/node-v14.18.1-linux-x64/bin/npm /usr/local/bin\n```\n\n``` cmd\nln -s /usr/local/src/node-v14.18.1-linux-x64/bin/node /usr/local/bin\n```\n\n验证是否安装完成，依次执行以下命令，返回对应版本号表示安装完成\n``` cmd\nnode -v\nnpm -v\n```\n\n![nodejs](/images/success-node.png)\n\n\n","tags":["node","Linux"],"categories":["Linux"]},{"title":"使用Hexo搭建博客教程(window环境)","url":"/2021/11/02/hello-world/","content":"Hexo 是一个快速、简洁且高效的博客框架，使用它你会发现搭建个人博客是如此的简单快捷，本篇文章将带你从零开始搭建个人博客并部署到github page上托管。\n\n<!-- more -->\nHexo简介\n=================\n[Hexo](https://hexo.io/zh-cn/) 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen\n\n特点：\n* 不可思议的快速 ─ 只要一眨眼静态文件即生成完成\n* 支持 Markdown\n* 仅需一道指令即可部署到 GitHub Pages 和 Heroku\n* 已移植 Octopress 插件\n* 高扩展性、自订性\n* 兼容于 Windows, Mac & Linux\n\n环境搭建\n=================\n\nHexo搭建步骤:\n1. 安装nodejs\n2. 安装git\n3. 安装Hexo\n4. 部署到github\n\n安装nodejs\n-----------------\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型,使其轻量又高效。Node.js 的包管理器 npm,是全球最大的开源库生态系统。\n\n[nodejs官网](http://nodejs.cn/)，选择LTS版本就行了\n\n![nodejs](/images/nodejs.jpg)\n\n根据步骤安装完成后打开命令行\n``` cmd\nnode -v\nnpm -v\n```\n\n看到如下图结果表明已安装完成\n\n![cmd](/images/cmd-node.jpg)\n\n安装git\n-----------------\nGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n[git官网](https://git-scm.com/), 直接下载最新版本就行了\n\n![git](/images/git.png)\n\n根据步骤安装完成后打开命令行\n``` cmd\ngit --version\n```\n\n看到如下图结果表明已安装完成\n\n![cmd-git](/images/cmd-git.jpg)\n\n安装Hexo\n-----------------\nHexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。\n\n[Hexo官网](https://hexo.io/zh-cn/), 根据官网安装流程来安装\n\n![git](/images/hexo.jpg)\n\n使用 npm 安装 Hexo\n\n``` cmd\nnpm install -g hexo-cli\n```\n\n根据步骤安装完成后打开命令行\n``` cmd\nhexo -v\n```\n\n看到如下图结果表明已安装完成\n\n![cmd-hexo](/images/cmd-hexo.jpg)\n\n选择一个工程放置的目录进行初始化，工程名称自己随便定义，我这里叫my-blog\n``` cmd\nhexo init my-blog\n```\n\n然后进入my-blog目录\n``` cmd\ncd my-blog\nnpm install\n```\n\n执行命令将hexo服务跑起来\n``` cmd\nhexo server\n```\n\n在浏览器输入localhost:4000就可以看到你生成的博客了\n\n![cmd-hexo](/images/hexo-init.png)\n","tags":["Hexo","node","npm","git","github"],"categories":["前端"]}]